/*!
 * @file example_stm32.c
 * @brief STM32 example for NeoPixel driver
 * @author Madison Gleydura (DeepSpace00)
 * @date 2025-08-04
 * 
 * This example assumes STM32CubeMX HAL is being used.
 * Make sure to configure the GPIO pin as output in CubeMX.
 */

#include "main.h"
#include "neopixel.h"
#include "neopixel_platform.h"
#include <stdio.h>

#define LED_COUNT   60     // Number of NeoPixels in strip
#define BRIGHTNESS  128    // Set brightness (0-255)

// Pin mapping - adjust based on your board configuration
// This example assumes pin 0 maps to GPIOA Pin 0
#define NEOPIXEL_PIN  0    // GPIO pin number (adjust your mapping in platform file)

// NeoPixel driver instance
neopixel_t strip;

// Function prototypes
void colorWipe(uint32_t color, uint32_t wait);
void theaterChase(uint32_t color, uint32_t wait);
void rainbow(uint8_t wait);
void rainbowCycle(uint8_t wait);
uint32_t wheel(uint8_t wheelPos);

int main(void) {
    // STM32 HAL initialization (generated by CubeMX)
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART2_UART_Init(); // If using UART for debug
    
    // Configure platform interface
    neopixel_interface_t interface = {
        .gpio_set_high = platform_gpio_set_high,
        .gpio_set_low = platform_gpio_set_low,
        .delay_us = platform_delay_us,
        .get_us_tick = platform_get_us_tick,
        .disable_interrupts = platform_disable_interrupts,
        .enable_interrupts = platform_enable_interrupts
    };
    
    // Initialize NeoPixel strip
    neopixel_status_t status = neopixel_init(&strip, NEOPIXEL_PIN, LED_COUNT, 
                                            NEO_GRB + NEO_KHZ800, interface);
    if (status != NEOPIXEL_OK) {
        // Handle initialization error
        printf("Failed to initialize NeoPixel: %s\r\n", neopixel_status_str(status));
        Error_Handler();
    }
    
    // Set brightness
    neopixel_set_brightness(&strip, BRIGHTNESS);
    
    printf("NeoPixel initialized successfully!\r\n");
    printf("Strip has %d LEDs\r\n", LED_COUNT);
    
    // Clear all pixels
    neopixel_clear(&strip);
    neopixel_show(&strip);
    
    while (1) {
        // Demo 1: Color wipe
        printf("Color wipe demo...\r\n");
        colorWipe(neopixel_color_rgb(255, 0, 0), 50);    // Red
        colorWipe(neopixel_color_rgb(0, 255, 0), 50);    // Green  
        colorWipe(neopixel_color_rgb(0, 0, 255), 50);    // Blue
        colorWipe(neopixel_color_rgb(0, 0, 0), 50);      // Off
        
        // Demo 2: Rainbow
        printf("Rainbow demo...\r\n");
        neopixel_rainbow(&strip, 0, 1, 255, 255);
        neopixel_show(&strip);
        HAL_Delay(1000);
        
        // Demo 3: Rainbow cycle
        printf("Rainbow cycle demo...\r\n");
        for (int i = 0; i < 5; i++) {  // 5 cycles
            rainbowCycle(20);
        }
        
        // Demo 4: Theater chase
        printf("Theater chase demo...\r\n");
        theaterChase(neopixel_color_rgb(127, 127, 127), 100); // White
        theaterChase(neopixel_color_rgb(127, 0, 0), 100);     // Red
        theaterChase(neopixel_color_rgb(0, 0, 127), 100);     // Blue
        
        HAL_Delay(2000);
    }
}

// Fill strip pixels one after another with a color
void colorWipe(uint32_t color, uint32_t wait) {
    for (int i = 0; i < LED_COUNT; i++) {
        neopixel_set_pixel_color_packed(&strip, i, color);
        neopixel_show(&strip);
        HAL_Delay(wait);
    }
}

// Input a value 0 to 255 to get a color value.
// Colors transition r - g - b - back to r.
uint32_t wheel(uint8_t wheelPos) {
    wheelPos = 255 - wheelPos;
    if (wheelPos < 85) {
        return neopixel_color_rgb(255 - wheelPos * 3, 0, wheelPos * 3);
    }
    if (wheelPos < 170) {
        wheelPos -= 85;
        return neopixel_color_rgb(0, wheelPos * 3, 255 - wheelPos * 3);
    }
    wheelPos -= 170;
    return neopixel_color_rgb(wheelPos * 3, 255 - wheelPos * 3, 0);
}

// Make a rainbow across the entire strip
void rainbow(uint8_t wait) {
    uint16_t i, j;
    
    for (j = 0; j < 256; j++) {
        for (i = 0; i < LED_COUNT; i++) {
            uint32_t color = wheel((i + j) & 255);
            neopixel_set_pixel_color_packed(&strip, i, color);
        }
        neopixel_show(&strip);
        HAL_Delay(wait);
    }
}

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint8_t wait) {
    uint16_t i, j;
    
    for (j = 0; j < 256; j++) {
        for (i = 0; i < LED_COUNT; i++) {
            uint32_t color = wheel(((i * 256 / LED_COUNT) + j) & 255);
            neopixel_set_pixel_color_packed(&strip, i, color);
        }
        neopixel_show(&strip);
        HAL_Delay(wait);
    }
}

// Theater-style crawling lights
void theaterChase(uint32_t color, uint32_t wait) {
    for (int a = 0; a < 10; a++) {  // Repeat 10 times
        for (int b = 0; b < 3; b++) { // 'b' counts from 0 to 2
            neopixel_clear(&strip);   // Turn all pixels off
            for (int c = b; c < LED_COUNT; c += 3) {
                neopixel_set_pixel_color_packed(&strip, c, color); // Turn every third pixel on
            }
            neopixel_show(&strip);
            HAL_Delay(wait);
        }
    }
}

// Error handler
void Error_Handler(void) {
    __disable_irq();
    while (1) {
        // Stay here
    }
}